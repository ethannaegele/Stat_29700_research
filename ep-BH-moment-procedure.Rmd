---
title: "ep-BH moment procedure"
author: "Ethan Naegele"
date: "2024-06-20"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(knockoff)
library(pracma)
library(tidyverse)
library(TreeTools)
```


```{r}
# junk function - do not use
ep_moment_method1 <- function(X, Y, alpha = .05, sigma = 1, moment = 2, dampen = FALSE){
  # In this setting, sigma is known
  # check that moment is an even integer
  if (!is.numeric(moment) | moment %% 2 != 0 | moment <= 0) {
    stop("Moment must be a positive even integer.")
  }
 
  standard_gaussian_moment <- DoubleFactorial(moment - 1) # formula for the even moments of standard Gaussian
  # Convert X to a data frame
  df_X <- as.data.frame(X)
  
  # Add Y to the dataframe
  df_X$Y <- Y
  
  # Fit the model using the formula
  model <- lm(Y ~ 0 + ., data=df_X)
  
  beta_covariance_mat <- vcov(model)
  
  beta_variance_estimates <- diag(beta_covariance_mat)
  
  beta_variances <- (sigma^2 / get_variance_parameter_estimate(X, Y)^2) * beta_variance_estimates
  
  beta_sds <- sqrt(beta_variances)
  beta_hats <- coef(model)
  z_scores <- beta_hats / beta_sds
  
  p_values <- 2 * (1 - pnorm(abs(z_scores)))
  e_values <- (beta_hats / beta_sds)^moment / standard_gaussian_moment
  if (dampen){
    e_values <- (1/2) + (1/2) * e_values # trick for dampening the volatility of the e values
  }
  rejected_indices <- ep_BH(p_values = p_values, e_values = e_values, alpha = alpha)
  
  return(rejected_indices)
  
}
```



# Other attempt

Simulation attempts showed that the function written above fails to control the FDR. Here, we are going to try to rewrite the function by using the same p value calculation from Sarkar and Tang's method, alongside the new e value calculation, then combine these with the combiner.

```{r}
get_beta_hat_2 <- function(X, Y){
  D <- diag(create.solve_equi(t(X) %*% X)) 
  X_ko <- create.fixed(X, method = 'equi')$Xk
  beta_hat_2 <- solve(D) %*% t(X - X_ko) %*% Y
  return(beta_hat_2)
}

```

On the first iteration, let's just follow the p value calculation from the paper, and on the second iteration we will compute the p value using the variance parameter $\sigma$, or $\tau$ as written in the paper. 

```{r}
ep_moment_method1_2 <- function(X, Y, alpha = .05, sigma = 1, moment = 2, dampen = FALSE){
  # In this setting, sigma is known
  # check that moment is an even integer
  if (!is.numeric(moment) | moment %% 2 != 0 | moment <= 0) {
    stop("Moment must be a positive even integer.")
  }
  
  D <- diag(create.solve_equi(t(X) %*% X))
  X_ko <- create.fixed(X, method = 'equi')$Xk
  beta_hat_2 <- solve(D) %*% t(X - X_ko) %*% Y # as defined in section 2 of sarkar and tang
 
  standard_gaussian_moment <- DoubleFactorial(moment - 1) # formula for the even moments of standard Gaussian
  
  # use the code from sarkar and tang method 1 to calculate P_t1
  d <- ncol(X)
  nu <- nrow(X) - 2 * d # n - 2d assuming n > 2d
  T1 <- get_T_1(X, Y)
  #T2 <- get_T_2(X, Y)
  P_t1 <- pf(T1^2, 1, nu, lower.tail = FALSE) # to calculate probabilities with the t^2_n distribution, have to use the F(1, n) distribution
  
  # Convert X to a data frame
  df_X <- as.data.frame(X)
  
  # Add Y to the dataframe
  df_X$Y <- Y
  
  # Fit the model using the formula
  beta_variances <- 2 * sigma^2 * diag(solve(D))
  beta_sds <- sqrt(beta_variances)
  
  e_values <- (beta_hat_2 / beta_sds)^moment / standard_gaussian_moment
  if (dampen){
    e_values <- (1/2) + (1/2) * e_values # trick for dampening the volatility of the e values
  }
  rejected_indices <- ep_BH(p_values = P_t1, e_values = e_values, alpha = alpha)
  
  return(rejected_indices)
  
}
```

trying to upgrade this method by calculating p values taking advantage of the fact that $\sigma$ is known here

```{r}
ep_moment_method1_2_sigma <- function(X, Y, alpha = .05, sigma = 1, moment = 2, dampen = FALSE){
  # In this setting, sigma is known
  # check that moment is an even integer
  if (!is.numeric(moment) | moment %% 2 != 0 | moment <= 0) {
    stop("Moment must be a positive even integer.")
  }
  
  standard_gaussian_moment <- DoubleFactorial(moment - 1) # formula for the even moments of standard Gaussian
  
  sigma_mat <- t(X) %*% X
  equi <- create_equicorrelated_mult(X, multiplier = 1.98) # USE THE MODIFIED FUNCTION FOR BETTER MATRIX CONDITION
  D <- equi$D
  X_ko <- equi$Xk
  two_sigma_minus_D_inv <- solve(2 * sigma_mat - D)
  beta_hat_1 <- two_sigma_minus_D_inv %*% t(X + X_ko) %*% Y
  beta_hat_2 <- solve(D) %*% t(X - X_ko) %*% Y # as defined in section 2 of sarkar and tang
 
  beta_hat_1_sds <- sqrt(diag(2 * sigma^2 * two_sigma_minus_D_inv)) # standard deviation of the beta_1 coefficient estimates
  z_scores <- beta_hat_1 / beta_hat_1_sds
  p_values <- 2 * (1 - pnorm(abs(z_scores)))

  beta_hat_2_sds <- sqrt(diag(2 * sigma^2 * solve(D))) # standard deviation of the beta_2 coefficient estimates
  
  e_values <- (beta_hat_2 / beta_hat_2_sds)^moment / standard_gaussian_moment
  if (dampen){
    e_values <- (1/2) + (1/2) * e_values # trick for dampening the volatility of the e values
  }
  rejected_indices <- ep_BH(p_values = p_values, e_values = e_values, alpha = alpha)
  
  return(rejected_indices)
  
}
```

THE METHOD BELOW IS THEORETICALLY KNOWN TO CONTROL FDR AT $\pi_0 \alpha$ DUE TO THEOREM 4 OF THE EP-BH PAPER

```{r}
ep_moment_method1_3_sigma <- function(X, Y, alpha = .05, sigma = 1, moment = 2, dampen = FALSE, multiplier = 1.9){
  # In this setting, sigma is known
  # check that moment is an even integer
  if (!is.numeric(moment) | moment %% 2 != 0 | moment <= 0) {
    stop("Moment must be a positive even integer.")
  }
  
  standard_gaussian_moment <- DoubleFactorial(moment - 1) # formula for the even moments of standard Gaussian
  
  sigma_mat <- t(X) %*% X
  equi <- create_equicorrelated_mult(X, multiplier = multiplier) # USE THE MODIFIED FUNCTION FOR BETTER MATRIX CONDITION
  D1 <- equi$D
  X_ko1 <- equi$Xk
  two_sigma_minus_D_inv <- solve(2 * sigma_mat - D1)
  beta_hat_1 <- two_sigma_minus_D_inv %*% t(X + X_ko1) %*% Y
  
  D2 <- diag(create.solve_equi(t(X) %*% X))
  X_ko2 <- create.fixed(X, method = 'equi')$Xk
  beta_hat_2 <- solve(D2) %*% t(X - X_ko2) %*% Y # as defined in section 2 of sarkar and tang
 
  beta_hat_1_sds <- sqrt(diag(2 * sigma^2 * two_sigma_minus_D_inv)) # standard deviation of the beta_1 coefficient estimates
  beta_hat_2_sds <- sqrt(diag(2 * sigma^2 * solve(D2))) # standard deviation of the beta_2 coefficient estimates
  z_scores <- beta_hat_2 / beta_hat_2_sds
  p_values <- 2 * (1 - pnorm(abs(z_scores)))

  e_values <- (beta_hat_1 / beta_hat_1_sds)^moment / standard_gaussian_moment
  if (dampen){
    e_values <- (1/2) + (1/2) * e_values # trick for dampening the volatility of the e values
  }
  rejected_indices <- ep_BH(p_values = p_values, e_values = e_values, alpha = alpha)
  
  return(rejected_indices)
  
}
```

# Unknown variance

```{r}
# formula for calculating the kth moment of the F(d1, d2) distribution
f_distribution_kth_moment <- function(d1, d2, k) {
  # Calculate the terms of the formula
  term1 <- (d2 / d1) ^ k
  term2 <- gamma((d1 / 2) + k)
  term3 <- gamma((d2 / 2) - k)
  term4 <- gamma(d1 / 2)
  term5 <- gamma(d2 / 2)
  
  # Calculate the final value
  result <- term1 * term2 * term3 / (term4 * term5)
  
  return(result)
}


```



```{r}
# This function is the primary approach to the moment method, which uses the F distribution, and uses 
# valid p values and e values. The p values are not independent, but since the p values are approximately equal to 
# p values one would get from the known sigma case, they are "approximately independent" 
# and empirically, the method controls the FDR in the cases I have examined.
ep_moment_method <- function(X, Y, alpha = .05, moment = 2, sigma = NULL, dampen = FALSE, multiplier = 1.9){
  # check that moment is an even integer
  if (!is.numeric(moment) | moment %% 2 != 0 | moment <= 0) {
    stop("Moment must be a positive even integer.")
  }
  
  if (is.null(sigma)){
  # the unknown variance version of the method
  nu <- nrow(X) - 2 * ncol(X)
  
  if (moment == 2){
    distribution_moment <- nu / (nu - 2) # Mean of the F(1, nu) distribution. Avoids computing the gamma function if n is large, which would otherwise break the function
  }
  else{
    distribution_moment <- f_distribution_kth_moment(1, nu, k = moment / 2) # not viable if n is large, since this computes the gamma function
  }
  
  
  sigma_mat <- t(X) %*% X
  equi <- create_equicorrelated_mult(X, multiplier = multiplier) # USE THE MODIFIED FUNCTION FOR BETTER MATRIX CONDITION
  D <- equi$D
  X_ko <- equi$Xk
  two_sigma_minus_D_inv <- solve(2 * sigma_mat - D)
  
  beta_hat_1 <- two_sigma_minus_D_inv %*% t(X + X_ko) %*% Y # as defined in section 2 of sarkar and tang
  
  sigma_hat <- get_variance_parameter_estimate(cbind(X, X_ko), Y)
  
  T2 <- get_T_2(X, Y)
  P_t2 <- pf(T2^2, 1, nu, lower.tail = FALSE) # to calculate probabilities with the t^2_n distribution, have to use the F(1, n) distribution
  
  beta_hat_1_sds <- sqrt(diag(2 * sigma_hat^2 * two_sigma_minus_D_inv))
  e_values <- (beta_hat_1 / beta_hat_1_sds)^moment / distribution_moment
  #e_values <- ((nu - 2) / nu) * (beta_hat_1^2 / beta_hat_1_variances)
  if (dampen){
    e_values <- (1/2) + (1/2) * e_values # trick for dampening the volatility of the e values
  }
  
  rejected_indices <- ep_BH(p_values = P_t2, e_values = e_values, alpha = alpha)
  }
  
  else if (sigma <= 0 | !is.numeric(sigma)){
    stop("Variance parameter sigma must be positive.")
  }
  else{
    rejected_indices <- ep_moment_method1_3_sigma(X, Y, 
                                                  alpha = alpha, 
                                                  sigma = sigma, 
                                                  moment = moment, 
                                                  dampen = dampen, 
                                                  multiplier = multiplier)
  }
  return(rejected_indices)
  
}
```


```{r}
ep_moment_method_alternate <- function(X, Y, alpha = .05, moment = 2, dampen = FALSE, multiplier = 1.9){
  # this function is an attempt at an alternate approach to the moment method, where
  # we instead estimate sigma with sigma_hat and use the method for when sigma is known, assuming that
  # sigma_hat is equal to sigma.
  X_ko <-  create_equicorrelated_mult(X, multiplier = multiplier)$Xk
  sigma_hat <- get_variance_parameter_estimate(cbind(X, X_ko), Y)
  rejected_indices <- ep_moment_method1_3_sigma(X, Y, 
                                                alpha = alpha, 
                                                sigma = sigma_hat, 
                                                moment = moment, 
                                                dampen = dampen,
                                                multiplier = multiplier)
  return(rejected_indices)
}
```





