---
title: "MCC simulations"
author: "Ethan Naegele"
date: "2024-07-29"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(knockoff)
library(pracma)
library(tidyverse)
library(TreeTools)
library(here)
library(foreach)
library(doParallel)
library(cknockoff)
```

LFL = Luo, Fithian, and Lei, referring to the authors of the "Improving knockoffs with conditional calibration" paper


# functions from conditional knockoffs paper

```{r}


# generate design matrix randomly
gene_X <- function(X_type = "IID_Normal", n, p, X_seed = NULL){
    if(!is.null(X_seed)){
        set.seed(X_seed)
    }
    
    #X_type <- str_split(X_type, pattern = "_D_")[[1]][1]
    
    model_X <- F # set False if experiment with fixed-X
    if(model_X){
        basis <- matrix(rnorm(n*p), n)
    } else{
        basis <- qr.Q(qr(matrix(rnorm(n*p), n)))
    }
    
    cor_radius <- 5
    if(X_type == "IID_Normal"){
        cov_mat <- diag(p)
        X <- matrix(rnorm(n*p), n)
    } else if(X_type == "Coef_AR"){
        rho <- 0.5
        
        cov_mat <- solve(rho^(abs(outer(1:p, 1:p, "-"))))
        normalizer <- diag(1 / sqrt(diag(cov_mat)))
        cov_mat <- normalizer %*% cov_mat %*% normalizer
        
        R <- chol(cov_mat)
        X <- basis %*% R
    } else if(X_type == "X_AR"){
        rho <- 0.5
        
        cov_mat <- rho^(abs(outer(1:p, 1:p, "-")))
        normalizer <- diag(1 / sqrt(diag(cov_mat)))
        cov_mat <- normalizer %*% cov_mat %*% normalizer
        
        R <- chol(cov_mat)
        X <- basis %*% R
    } else if(X_type == "Homo_Block"){
        rho <- 0.5
        block_size <- 10

        blockSigma <- matrix(rho, block_size, block_size)
        diag(blockSigma) <- 1

        cov_mat <- as.matrix(diag(p / block_size) %x% blockSigma)
        normalizer <- diag(1 / sqrt(diag(cov_mat)))
        cov_mat <- normalizer %*% cov_mat %*% normalizer
        
        R <- chol(cov_mat)
        X <- basis %*% R
    } else if(X_type == "MCC"){
        if(n %% (p+1) == 0){
            X <- lapply(1:(n/(p+1)), function(i){
                rbind(diag(rep(1, p)), rep(0, p))
            })
            X <- do.call(rbind, X)
            X <- scale(X, center = T, scale = F)
            X <- scale(X, center = F, scale = sqrt(colSums(X^2)))
        } else{
            cov_mat <- matrix(-1/p, p, p)
            diag(cov_mat) <- 1
            
            R <- chol(cov_mat)
            X <- basis %*% R
        }
    } else if(X_type == "MCC_Block"){
        block_size <- 5
        
        blockSigma <- matrix(-1/block_size, block_size, block_size)
        diag(blockSigma) <- 1
        
        cov_mat <- as.matrix(diag(p / block_size) %x% blockSigma)
        
        R <- chol(cov_mat)
        X <- basis %*% R
    } else if(X_type == "Sparse"){
        sparsity <- 0.01
        X <- diag(1, nrow = n, ncol = p)
        lower_tri <- lower.tri(X)
        X[lower_tri] <- replicate(sum(lower_tri), rbinom(1, 1, sparsity))
    }
    # X <- scale(X, center = FALSE, scale = sqrt(colSums(X^2)))
    if(!exists("cov_mat")) cov_mat <- NA

    return(list(X = X, Xcov.true = cov_mat))
}

```



# my stuff

need to define base BH, as per the LFL paper

```{r}
bh <- function(p_values, alpha = .05){
  Q_BH <- p.adjust(p_values, method = 'BH')
  rejected_indices <- which(Q_BH <= alpha)
  return(rejected_indices)
}
```

```{r}
bh_regression <- function(X, Y, alpha = .05){
  sigma_hat <- get_variance_parameter_estimate(X, Y)
  model <- lm(Y ~ 0 + ., data=as.data.frame(X))
  beta_hat <- coef(model)
  sigma_mat_inv <- solve(t(X) %*% X)
  beta_hat_sds <- sqrt(diag(sigma_hat^2 * sigma_mat_inv))
  t_statistics <- beta_hat / beta_hat_sds
  p_values <- 2 * (1 - pt(abs(t_statistics), df = nrow(X) - ncol(X)))
  rejected_indices <- bh(p_values = p_values, alpha = alpha)
  return(rejected_indices)
}
```



```{r}
get_mcc_regression_model <- function(type = 'MCC', n, d, a, num_true_signals, random_true_signal_indices = TRUE){
  if (type != 'MCC' & type != 'MCC_Block' & type != 'X_AR' & type != 'Coef_AR' & type != 'IID_Normal'){
    stop("Type should be 'MCC', 'MCC_Block', 'X_AR', 'Coef_AR', or 'IID_Normal'.")
  }
  X <- gene_X(X_type = type, n = n, p = d)$X
  if (random_true_signal_indices){
  nonzero_indices <- sort(sample(d, num_true_signals)) # randomly sample some indices to be the true signal indices
  beta_true <- a * (1:d %in% nonzero_indices) # all the other positions in the vector will be 0
}
else{
  nonzero_indices <- 1:num_true_signals
  beta_true <- c(rep(a, times = num_true_signals), rep(0, times = d - num_true_signals))
}

Y <- X %*% beta_true + rnorm(n) # linear regression model

return(list('X' = X, 'Y' = Y, 'nonzero_indices' = nonzero_indices))
}
```


```{r}
run_sarkar_tang_method1_mcc_simulation <- function(type = 'MCC', n, d, a, num_true_sigs, alpha = .05, num_iter = 500){
  # Sets up the regression problem with specified dimensions and number of true signals, all of which have
  # the same amplitude. 
  fdp_vec <- numeric(num_iter)
pwr_vec <- c(num_iter)
for (m in 1:num_iter){
  feature_indices <- 1:d
  regression <- get_mcc_regression_model(type = type, n = n, d = d, a = a, num_true_signals = num_true_sigs)
  true_nonzero_indices <- regression$nonzero_indices
  rejected_indices <- sarkar_tang_method1(regression$X, regression$Y, alpha = alpha)
  num_rejections <- length(rejected_indices)
  num_correct_rejections <- length(intersect(rejected_indices, true_nonzero_indices))
  num_false_rejections <- length(intersect(feature_indices[-true_nonzero_indices], rejected_indices))
  fdp_vec[m] <- num_false_rejections / max(num_rejections, 1)
  pwr_vec[m] <- num_correct_rejections / max(length(true_nonzero_indices), 1)
}
fdr <- mean(fdp_vec)
pwr <- mean(pwr_vec)
return(list(fdr = fdr, power = pwr))
}
```


```{r}
run_bh_mcc_simulation <- function(type = 'MCC', n, d, a, num_true_sigs, alpha = .05, num_iter = 500){
  # Sets up the regression problem with specified dimensions and number of true signals, all of which have
  # the same amplitude. 
  fdp_vec <- numeric(num_iter)
pwr_vec <- c(num_iter)
for (m in 1:num_iter){
  feature_indices <- 1:d
  regression <- get_mcc_regression_model(type = type, n = n, d = d, a = a, num_true_signals = num_true_sigs)
  true_nonzero_indices <- regression$nonzero_indices
  rejected_indices <- bh_regression(regression$X, regression$Y, alpha = alpha)
  num_rejections <- length(rejected_indices)
  num_correct_rejections <- length(intersect(rejected_indices, true_nonzero_indices))
  num_false_rejections <- length(intersect(feature_indices[-true_nonzero_indices], rejected_indices))
  fdp_vec[m] <- num_false_rejections / max(num_rejections, 1)
  pwr_vec[m] <- num_correct_rejections / max(length(true_nonzero_indices), 1)
}
fdr <- mean(fdp_vec)
pwr <- mean(pwr_vec)
return(list(fdr = fdr, power = pwr))
}
```


```{r}
run_ep_moment_method_mcc_simulation <- function(type = 'MCC', n, d, a, num_true_sigs, 
                                                num_iter = 500, 
                                                moment = 2,
                                                alpha = .05,
                                                dampen = FALSE){
  # Sets up the regression problem with specified dimensions and number of true signals, all of which have
  # the same amplitude. 
  fdp_vec <- numeric(num_iter)
pwr_vec <- c(num_iter)
for (m in 1:num_iter){
  feature_indices <- 1:d
  regression <- get_mcc_regression_model(type = type, n = n, d = d, a = a, num_true_signals = num_true_sigs)
  true_nonzero_indices <- regression$nonzero_indices
  rejected_indices <- ep_moment_method(regression$X, regression$Y, moment = moment, alpha = alpha, 
                                        dampen = dampen)
  num_rejections <- length(rejected_indices)
  num_correct_rejections <- length(intersect(rejected_indices, true_nonzero_indices))
  num_false_rejections <- length(intersect(feature_indices[-true_nonzero_indices], rejected_indices))
  fdp_vec[m] <- num_false_rejections / max(num_rejections, 1)
  pwr_vec[m] <- num_correct_rejections / max(length(true_nonzero_indices), 1)
}
fdr <- mean(fdp_vec)
pwr <- mean(pwr_vec)
return(list(fdr = fdr, power = pwr))
}
```


```{r}
run_ep_moment_method_alternate_mcc_simulation <- function(type = 'MCC', n, d, a, num_true_sigs, 
                                                          alpha = .05, 
                                                          num_iter = 500, 
                                                          moment = 2, 
                                                          dampen = FALSE){
  # Sets up the regression problem with specified dimensions and number of true signals, all of which have
  # the same amplitude. 
  fdp_vec <- numeric(num_iter)
pwr_vec <- c(num_iter)
for (m in 1:num_iter){
  feature_indices <- 1:d
  regression <- get_mcc_regression_model(type = type, n = n, d = d, a = a, num_true_signals = num_true_sigs)
  true_nonzero_indices <- regression$nonzero_indices
  rejected_indices <- ep_moment_method_alternate(regression$X, regression$Y, moment = moment, alpha = alpha, 
                                        dampen = dampen)
  num_rejections <- length(rejected_indices)
  num_correct_rejections <- length(intersect(rejected_indices, true_nonzero_indices))
  num_false_rejections <- length(intersect(feature_indices[-true_nonzero_indices], rejected_indices))
  fdp_vec[m] <- num_false_rejections / max(num_rejections, 1)
  pwr_vec[m] <- num_correct_rejections / max(length(true_nonzero_indices), 1)
}
fdr <- mean(fdp_vec)
pwr <- mean(pwr_vec)
return(list(fdr = fdr, power = pwr))
}
```



```{r}
run_knockoffs_mcc_simulation <- function(type = 'MCC', n, d, a, num_true_sigs, alpha = .05, method = 'equi', num_iter = 500){
  # Sets up the regression problem with specified dimensions and number of true signals, all of which have
  # the same amplitude. 
  # Runs the simulation by generating the regression problems and then runs fixed X knockoffs as described in Barber and Candes.
  
  
  fdp_vec <- numeric(num_iter)
pwr_vec <- c(num_iter)
for (m in 1:num_iter){
  feature_indices <- 1:d
  regression <- get_mcc_regression_model(type = type, n = n, d = d, a = a, num_true_signals = num_true_sigs)
  true_nonzero_indices <- regression$nonzero_indices
  rejected_indices <- knockoff_procedure(regression$X, 
                                         regression$Y, 
                                         alpha = alpha, 
                                         method = method)
  num_rejections <- length(rejected_indices)
  num_correct_rejections <- length(intersect(rejected_indices, true_nonzero_indices))
  num_false_rejections <- length(intersect(feature_indices[-true_nonzero_indices], rejected_indices))
  fdp_vec[m] <- num_false_rejections / max(num_rejections, 1)
  pwr_vec[m] <- num_correct_rejections / max(length(true_nonzero_indices), 1)
}
fdr <- mean(fdp_vec)
pwr <- mean(pwr_vec)
return(list(fdr = fdr, power = pwr))
}
```

```{r}
run_CKnockoffs_mcc_simulation <- function(type = 'MCC', n, d, a, num_true_sigs, alpha = .05, num_iter = 500){
  # Sets up the regression problem with specified dimensions and number of true signals, all of which have
  # the same amplitude. 
  # Runs the simulation by generating the regression problems and then runs CONDITIONAL KNOCKOFFS 
  
  fdp_vec <- numeric(num_iter)
pwr_vec <- c(num_iter)
for (m in 1:num_iter){
  feature_indices <- 1:d
  regression <- get_mcc_regression_model(type = type, n = n, d = d, a = a, num_true_signals = num_true_sigs)
  true_nonzero_indices <- regression$nonzero_indices
  rejected_indices <- cknockoff(regression$X, 
                                regression$Y,
                                intercept = FALSE,
                                alpha = alpha)$selected
  num_rejections <- length(rejected_indices)
  num_correct_rejections <- length(intersect(rejected_indices, true_nonzero_indices))
  num_false_rejections <- length(intersect(feature_indices[-true_nonzero_indices], rejected_indices))
  fdp_vec[m] <- num_false_rejections / max(num_rejections, 1)
  pwr_vec[m] <- num_correct_rejections / max(length(true_nonzero_indices), 1)
}
fdr <- mean(fdp_vec)
pwr <- mean(pwr_vec)
return(list(fdr = fdr, power = pwr))
}
```



# Setting simulation functions for each method

```{r}
run_sarkar_tang_method1_mcc_lfl_setting_simulation <- function(type = 'MCC', a_vec = c(2, 4, 6, 8, 10), 
                                                               alpha = .05, 
                                                               num_iter = 500){
  # Ensure alpha is a vector
  if (is.numeric(alpha) && length(alpha) == 1) {
    alpha <- c(alpha)
  }
  
  # Initialize result lists
  result_list <- list()
  
  # Iterate over combinations of a_vec and alpha
  for (amp in a_vec){
    for (alp in alpha){
      result <- run_sarkar_tang_method1_mcc_simulation(type = type,
                                                       n = 1000,
                                                       d = 100,
                                                       a = amp, 
                                                       num_true_sigs = 10,
                                                       alpha = alp,
                                                       num_iter = num_iter)
      # Store the results in a list
      result_list[[paste("a", amp, "alpha", alp, sep = "_")]] <- data.frame(a = amp, alpha = alp, power = result$power, fdr = result$fdr)
    }
  }
  
  # Combine all results into a single data frame
  result_df <- do.call(rbind, result_list)
  return(result_df)
}

```

```{r}
run_bh_mcc_lfl_setting_simulation <- function(type = 'MCC', a_vec = c(2, 4, 6, 8, 10), 
                                                               alpha = .05, 
                                                               num_iter = 500){
  # Ensure alpha is a vector
  if (is.numeric(alpha) && length(alpha) == 1) {
    alpha <- c(alpha)
  }
  
  # Initialize result lists
  result_list <- list()
  
  # Iterate over combinations of a_vec and alpha
  for (amp in a_vec){
    for (alp in alpha){
      result <- run_bh_mcc_simulation(type = type,
                                                       n = 1000,
                                                       d = 100,
                                                       a = amp, 
                                                       num_true_sigs = 10,
                                                       alpha = alp,
                                                       num_iter = num_iter)
      # Store the results in a list
      result_list[[paste("a", amp, "alpha", alp, sep = "_")]] <- data.frame(a = amp, alpha = alp, power = result$power, fdr = result$fdr)
    }
  }
  
  # Combine all results into a single data frame
  result_df <- do.call(rbind, result_list)
  return(result_df)
}

```


```{r}
run_ep_moment_method_mcc_lfl_setting_simulation <- function(type = 'MCC', a_vec = c(2, 4, 6, 8, 10), 
                                                               alpha = .05,
                                                            moment = 2, 
                                                            dampen = FALSE,
                                                               num_iter = 500){
  # Ensure alpha is a vector
  if (is.numeric(alpha) && length(alpha) == 1) {
    alpha <- c(alpha)
  }
  
  # Initialize result lists
  result_list <- list()
  
  # Iterate over combinations of a_vec and alpha
  for (amp in a_vec){
    for (alp in alpha){
      result <- run_ep_moment_method_mcc_simulation(type = type,
                                                       n = 1000,
                                                       d = 100,
                                                       a = amp, 
                                                    moment = moment,
                                                    dampen = dampen,
                                                       num_true_sigs = 10,
                                                       alpha = alp,
                                                       num_iter = num_iter)
      # Store the results in a list
      result_list[[paste("a", amp, "alpha", alp, sep = "_")]] <- data.frame(a = amp, alpha = alp, power = result$power, fdr = result$fdr)
    }
  }
  
  # Combine all results into a single data frame
  result_df <- do.call(rbind, result_list)
  return(result_df)
}
```

```{r}
run_ep_moment_method_alternate_mcc_lfl_setting_simulation <- function(type = 'MCC', a_vec = c(2, 4, 6, 8, 10), 
                                                               alpha = .05,
                                                            moment = 2, 
                                                            dampen = FALSE,
                                                               num_iter = 500){
  # Ensure alpha is a vector
  if (is.numeric(alpha) && length(alpha) == 1) {
    alpha <- c(alpha)
  }
  
  # Initialize result lists
  result_list <- list()
  
  # Iterate over combinations of a_vec and alpha
  for (amp in a_vec){
    for (alp in alpha){
      result <- run_ep_moment_method_alternate_mcc_simulation(type = type,
                                                       n = 1000,
                                                       d = 100,
                                                       a = amp, 
                                                    moment = moment,
                                                    dampen = dampen,
                                                       num_true_sigs = 10,
                                                       alpha = alp,
                                                       num_iter = num_iter)
      # Store the results in a list
      result_list[[paste("a", amp, "alpha", alp, sep = "_")]] <- data.frame(a = amp, alpha = alp, power = result$power, fdr = result$fdr)
    }
  }
  
  # Combine all results into a single data frame
  result_df <- do.call(rbind, result_list)
  return(result_df)
}
```



```{r}
run_knockoffs_mcc_lfl_setting_simulation <- function(type = 'MCC', a_vec = c(2, 4, 6, 8, 10), 
                                                               alpha = .05,
                                                               method = 'equi',
                                                               num_iter = 500){
  # Ensure alpha is a vector
  if (is.numeric(alpha) && length(alpha) == 1) {
    alpha <- c(alpha)
  }
  
  # Initialize result lists
  result_list <- list()
  
  # Iterate over combinations of a_vec and alpha
  for (amp in a_vec){
    for (alp in alpha){
      result <- run_knockoffs_mcc_simulation(type = type,
                                                       n = 1000,
                                                       d = 100,
                                                       a = amp, 
                                                    method = method,
                                                       num_true_sigs = 10,
                                                       alpha = alp,
                                                       num_iter = num_iter)
      # Store the results in a list
      result_list[[paste("a", amp, "alpha", alp, sep = "_")]] <- data.frame(a = amp, alpha = alp, power = result$power, fdr = result$fdr)
    }
  }
  
  # Combine all results into a single data frame
  result_df <- do.call(rbind, result_list)
  return(result_df)
}
```


```{r}
run_CKnockoffs_mcc_lfl_setting_simulation <- function(type = 'MCC', 
                                                      a_vec = c(2, 4, 6, 8, 10), 
                                                      alpha = .05,
                                                      num_iter = 500){
  # Ensure alpha is a vector
  if (is.numeric(alpha) && length(alpha) == 1) {
    alpha <- c(alpha)
  }
  
  # Initialize result lists
  result_list <- list()
  
  # Iterate over combinations of a_vec and alpha
  for (amp in a_vec){
    for (alp in alpha){
      result <- run_CKnockoffs_mcc_simulation(type = type,
                                                       n = 1000,
                                                       d = 100,
                                                       a = amp,
                                                       num_true_sigs = 10,
                                                       alpha = alp,
                                                       num_iter = num_iter)
      # Store the results in a list
      result_list[[paste("a", amp, "alpha", alp, sep = "_")]] <- data.frame(a = amp, alpha = alp, power = result$power, fdr = result$fdr)
    }
  }
  
  # Combine all results into a single data frame
  result_df <- do.call(rbind, result_list)
  return(result_df)
}
```


# small scale - trying to get a rough calibration of the BH

we choose $\beta^*$ such that base BH with $\alpha = .20$ has power of about 35% for the setting. In some of the experiments below, we approximated the power to be 50%, but in the full scale simulation, the power ended up being 35%. 

## mcc


```{r}
set.seed(17)
run_bh_mcc_lfl_setting_simulation(a_vec = c(3.63), alpha = .2, num_iter = 200)
```

mcc calibration is $\beta^* \approx 3.63$. 

## mcc block


```{r}
set.seed(20)
run_bh_mcc_lfl_setting_simulation(type = 'MCC_Block', a_vec = c(3.2), alpha = .2, num_iter = 300)
```


mcc block calibration is $\beta^* \approx 3.2$.



## IID normal

```{r}
set.seed(30)
run_bh_mcc_lfl_setting_simulation(type = 'IID_Normal', a_vec = c(.073), alpha = .2, num_iter = 1000)
```

for IID normal, we have $\beta^* \approx .073$. 

## X_AR

```{r}
set.seed(31)
run_bh_mcc_lfl_setting_simulation(type = 'X_AR', a_vec = c(2.83), alpha = .2, num_iter = 1000)
```

for X_AR, we have $\beta^* \approx 2.83$. 
