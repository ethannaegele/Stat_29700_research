---
title: "Sarkar and Tang simulation replication"
author: "Ethan Naegele"
date: "2024-04-19"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(knockoff)
library(Matrix)
library(pracma)
```



# Internal functions in knockoffs package for computation purposes

```{r}
# Fast versions of diag(d) %*% X and X %*% diag(d).
`%diag*%` <- function(d, X) d * X
`%*diag%` <- function(X, d) t(t(X) * d)
```

```{r}
is_posdef = function(A, tol=1e-9) {
  p = nrow(matrix(A))
  
  if (p<500) {
    lambda_min = min(eigen(A)$values)
  }
  else {
    oldw <- getOption("warn")
    options(warn = -1)
    lambda_min = RSpectra::eigs(A, 1, which="SM", opts=list(retvec = FALSE, maxitr=100, tol))$values
    options(warn = oldw)
    if( length(lambda_min)==0 ) {
      # RSpectra::eigs did not converge. Using eigen instead."
      lambda_min = min(eigen(A)$values)
    }
  }
  return (lambda_min>tol*10)
}
```

```{r}
# Scale the columns of a matrix to have unit norm.
normc = function(X,center=T) {
  X.centered = scale(X, center=center, scale=F)
  X.scaled = scale(X.centered, center=F, scale=sqrt(colSums(X.centered^2)))
  X.scaled[,] # No attributes
}
```



```{r}
# Reduced SVD with canonical sign choice.
# 
# Our convention is that the sign of each vector in U is chosen such that the
# coefficient with the largest absolute value is positive.
canonical_svd = function(X) {
  X.svd = tryCatch({
    svd(X)
  }, warning = function(w){}, error = function(e) {
      stop("SVD failed in the creation of fixed-design knockoffs. Try upgrading R to version >= 3.3.0")
  }, finally = {})
  
  for (j in 1:min(dim(X))) {
    i = which.max(abs(X.svd$u[,j]))
    if (X.svd$u[i,j] < 0) {
      X.svd$u[,j] = -X.svd$u[,j]
      X.svd$v[,j] = -X.svd$v[,j]
  }
    }
  return(X.svd)
}

```


```{r}
#' Compute the SVD of X and construct an orthogonal matrix U_perp such that U_perp * U = 0.
#'  
decompose <- function(X, randomize=FALSE) {
  n = nrow(X); p = ncol(X)
  stopifnot(n >= 2*p)
  
  result = canonical_svd(X)
  Q = qr.Q(qr(cbind(result$u, matrix(0,n,p))))
  u_perp = Q[,(p+1):(2*p)]
  if (randomize) {
      Q = qr.Q(qr(rnorm_matrix(p,p)))
      u_perp = u_perp %*% Q
  }
  result$u_perp = u_perp
  result
}
```


```{r}
# I created the first function from the knockoffs package code
create_equicorrelated_D <- function(X, randomize=FALSE) {
  # Compute SVD and U_perp.
  X = normc(X, center=F)
  X.svd = decompose(X, randomize)
  
  # Set s = min(2 * smallest eigenvalue of X'X, 1), so that all the correlations
  # have the same value 1-s.
  if (any(X.svd$d <= 1e-5 * max(X.svd$d)))
    stop(paste('Data matrix is rank deficient.',
               'Equicorrelated knockoffs will have no power.'))
  lambda_min = min(X.svd$d)^2
  s = min(2*lambda_min, 1)
  s_vec <- rep(s, times = ncol(X))
  return(diag(s_vec))
}


create_equicorrelated_knockoffs <- function(X, randomize=FALSE) {
  # Compute SVD and U_perp.
  X = normc(X, center=F)
  X.svd = decompose(X, randomize)
  
  # Set s = min(2 * smallest eigenvalue of X'X, 1), so that all the correlations
  # have the same value 1-s.
  if (any(X.svd$d <= 1e-5 * max(X.svd$d)))
    stop(paste('Data matrix is rank deficient.',
               'Equicorrelated knockoffs will have no power.'))
  lambda_min = min(X.svd$d)^2
  s = min(2*lambda_min, 1)
  
  # Construct the knockoff according to Equation 1.4.
  s_diff = pmax(0, 2*s - (s/X.svd$d)^2) # can be negative due to numerical error
  X_ko = (X.svd$u %*diag% (X.svd$d - s / X.svd$d) +
          X.svd$u_perp %*diag% sqrt(s_diff)) %*% t(X.svd$v)
  return(X_ko)
}

```




```{r}
# THIS IS A FUNCTION FROM THE PACKAGE, BUT I CHANGED THE OUTPUT TO BE DIAG(S)
create.solve_equi_personal <- function(Sigma) {
  # Check that covariance matrix is symmetric
  stopifnot(isSymmetric(Sigma))
  p = nrow(Sigma)
  tol = 1e-10
  # Convert the covariance matrix to a correlation matrix
  G = cov2cor(Sigma)
  
  # Check that the input matrix is positive-definite
  if (!is_posdef(G)) {
    stop('The covariance matrix is not positive-definite: cannot solve SDP',immediate.=T)
  }
  
  if (p>2) {
    converged=FALSE
    maxitr=10000
    while (!converged) {
      lambda_min = RSpectra::eigs(G, 1, which="SR", opts=list(retvec = FALSE, maxitr=100000, tol=1e-8))$values
      if (length(lambda_min)==1) {
        converged = TRUE
      } else {
        if (maxitr>1e8) {
          warning('In creation of equi-correlated knockoffs, while computing the smallest eigenvalue of the 
                covariance matrix. RSpectra::eigs did not converge. Giving up and computing full SVD with built-in R function.',immediate.=T)
          lambda_min = eigen(G, symmetric=T, only.values = T)$values[p]
          converged=TRUE
        } else {
          warning('In creation of equi-correlated knockoffs, while computing the smallest eigenvalue of the 
                covariance matrix. RSpectra::eigs did not converge. Trying again with increased number of iterations.',immediate.=T)
          maxitr = maxitr*10
        }
      }
    }
  } else {
    lambda_min = eigen(G, symmetric=T, only.values = T)$values[p]
  }
  
  if (lambda_min<0) {
    stop('In creation of equi-correlated knockoffs, while computing the smallest eigenvalue of the 
                covariance matrix. The covariance matrix is not positive-definite.')
  }
  
  s = rep(1, nrow(Sigma)) * min(2*lambda_min, 1)
  
  # Compensate for numerical errors (feasibility)
  psd = 0;
  s_eps = 1e-8;
  while (psd==0) {
    psd = is_posdef(2*G-diag(s*(1-s_eps),length(s)))
    if (!psd) {
      s_eps = s_eps*10
    }
  }
  s = s*(1-s_eps)
  
  # Scale back the results for a covariance matrix
  return(diag(s))
}
```



```{r}
# I MODIFIED THE FUNCTION FROM THE ORIGINAL TO JUST RETURN DIAG(S)
create.solve_sdp_personal <- function(Sigma, gaptol=1e-6, maxit=1000, verbose=FALSE) {
  # Check that covariance matrix is symmetric
  stopifnot(isSymmetric(Sigma))
  # Convert the covariance matrix to a correlation matrix
  G = cov2cor(Sigma)
  p = dim(G)[1]
  
  # Check that the input matrix is positive-definite
  if (!is_posdef(G)) {
    warning('The covariance matrix is not positive-definite: knockoffs may not have power.', immediate.=T)
  }
  
  # Convert problem for SCS
  
  # Linear constraints
  Cl1 = rep(0,p)
  Al1 = -Matrix::Diagonal(p)
  Cl2 = rep(1,p)
  Al2 = Matrix::Diagonal(p)
  
  # Positive-definite cone
  d_As = c(diag(p))
  As = Matrix::Diagonal(length(d_As), x=d_As)
  As = As[which(Matrix::rowSums(As) > 0),] 
  Cs = c(2*G)
  
  # Assemble constraints and cones
  A = cbind(Al1,Al2,As)
  C = matrix(c(Cl1,Cl2,Cs),1)
  K=NULL
  K$s=p
  K$l=2*p
  
  # Objective
  b = rep(1,p)
  
  # Solve SDP with Rdsdp
  OPTIONS=NULL
  OPTIONS$gaptol=gaptol
  OPTIONS$maxit=maxit
  OPTIONS$logsummary=0
  OPTIONS$outputstats=0
  OPTIONS$print=0
  if(verbose) cat("Solving SDP ... ")
  sol = Rdsdp::dsdp(A,b,C,K,OPTIONS)
  if(verbose) cat("done. \n")
  
  # Check whether the solution is feasible
  if( ! identical(sol$STATS$stype,"PDFeasible")) {
    warning('The SDP solver returned a non-feasible solution. Knockoffs may lose power.')
  }
  
  # Clip solution to correct numerical errors (domain)
  s = sol$y
  s[s<0]=0
  s[s>1]=1
  
  # Compensate for numerical errors (feasibility)
  if(verbose) cat("Verifying that the solution is correct ... ")
  psd = 0
  s_eps = 1e-8
  while ((psd==0) & (s_eps<=0.1)) {
    if (is_posdef(2*G-diag(s*(1-s_eps),length(s)),tol=1e-9)) {
      psd  = 1
    }
    else {
      s_eps = s_eps*10
    }
  }
  s = s*(1-s_eps)
  s[s<0]=0
  if(verbose) cat("done. \n")
  
  # Verify that the solution is correct
  if (all(s==0)) {
    warning('In creation of SDP knockoffs, procedure failed. Knockoffs will have no power.',immediate.=T)
  }
  
  # Scale back the results for a covariance matrix
  return(diag(s))
}
```

```{r}
# COPIED FROM THE INTERNAL FUNCTION FROM THE PACKAGE
create_sdp_knockoffs <- function(X, randomize=FALSE) {
  # Compute SVD and U_perp.
  X.svd = decompose(X, randomize)
  
  # Check for rank deficiency.
  tol = 1e-5
  d = X.svd$d
  d_inv = 1 / d
  d_zeros = d <= tol*max(d)
  if (any(d_zeros)) {
    warning(paste('Data matrix is rank deficient.',
                  'Model is not identifiable, but proceeding with SDP knockoffs'),immediate.=T)
    d_inv[d_zeros] = 0
  }
  
  # Compute the Gram matrix and its (pseudo)inverse.
  G = (X.svd$v %*diag% d^2) %*% t(X.svd$v)
  G_inv = (X.svd$v %*diag% d_inv^2) %*% t(X.svd$v)
  
  # Optimize the parameter s of Equation 1.3 using SDP.
  s = create.solve_sdp_personal(G)
  s[s <= tol] = 0
  
  # Construct the knockoff according to Equation 1.4:
  C.svd = canonical_svd(2*diag(s) - (s %diag*% G_inv %*diag% s))
  X_ko = X - (X %*% G_inv %*diag% s) + 
    (X.svd$u_perp %*diag% sqrt(pmax(0, C.svd$d))) %*% t(C.svd$v)
}

```






# other calculations


```{r}
X_new <- cbind(regression$X, create.fixed(regression$X, method = 'equi')$Xk)
```

```{r}
rcond(t(X_new) %*% X_new)
```

```{r}
create.solve_equi(t(X_new) %*% X_new)
```




```{r}
create.fixed(regression$X, method = 'equi')$Xk == create_equicorrelated_knockoffs(regression$X)
```

```{r}
create.fixed(regression$X)$Xk == create_sdp_knockoffs(regression$X)
```

```{r}
create.solve_sdp_personal(t(regression$X) %*% regression$X)
```


```{r}
solve(t(X_new) %*% X_new)
```




```{r}
create.fixed(regression$X, method = 'equi')$Xk
```



```{r}
create_equicorrelated_knockoffs(regression$X)
```


```{r}
create_equicorrelated_D(regression$X)
```


```{r}
create_equicorrelated_knockoffsv2 <- function(X, randomize=FALSE){
  # Construct the knockoff according to Equation 1.4.
  s <- create.solve_equi(t(X) %*% X)
  X.svd = decompose(X, randomize)
  s_diff = pmax(0, 2*s - (s/X.svd$d)^2) # can be negative due to numerical error
  X_ko = (X.svd$u %*diag% (X.svd$d - s / X.svd$d) +
          X.svd$u_perp %*diag% sqrt(s_diff)) %*% t(X.svd$v)
  return(X_ko)
}
```



```{r}
create_equicorrelated_knockoffs(regression$X)
```

```{r}
create_equicorrelated_D(regression$X)
```


```{r}
create.solve_equi(t(regression$X) %*% regression$X)
```



```{r}
X_ko <- create.fixed(regression$X)$Xk
#get_variance_parameter_estimate(cbind(regression$X, X_ko), regression$Y)
X_temp <- cbind(regression$X, X_ko)
solve(t(X_temp) %*% X_temp)
```

```{r}
get_variance_parameter_estimate(X_temp, regression$Y)
```


```{r}
get_T_1(regression$X, regression$Y)
```

```{r}
get_T_2(regression$X, regression$Y)
```

```{r}
results <- sarkar_tang_method1(regression$X, regression$Y, .05)
```

```{r}
length(results)
```

```{r}
set.seed(12)
 num_true_signals <- 20
  d <- 30
  feature_indices <- 1:d
  regression <- get_regression_model(n = 100, d = d, a = 4, num_true_signals = num_true_signals)
  true_nonzero_indices <- regression$nonzero_indices
  rejected_indices <- sarkar_tang_method1(regression$X, regression$Y, alpha = .05)
```


```{r}
regression <- get_regression_model(n = 200, d = 30, a = 2, num_true_signals = 1)
#get_T_1(regression$X, regression$Y)
#get_T_2(regression$X, regression$Y)
```

```{r}
set.seed(12)
X_ko <- create.fixed(regression$X, method = 'sdp')$Xk
X_temp <- cbind(regression$X, X_ko)
rcond(t(X_temp) %*% X_temp)
qr_decomp <- qr(t(X_temp) %*% X_temp)
solve(qr.R(qr_decomp), qr.Q(qr_decomp))
```

```{r}
library(pracma)
```

```{r}
inv(t(X_temp) %*% X_temp)
```

```{r}
X <- matrix(runif(100), ncol=5)  # 20 observations, 5 predictors
Y <- rnorm(20)  # 20 observations

# Fit the model
estimate <- get_variance_parameter_estimate(X, Y)

# Print the summary of the model
estimate
```

```{r}
fit_linear_model <- function(X, Y) {
  # Ensure Y is a vector and has appropriate length
  if (!is.vector(Y) || length(Y) != nrow(X)) {
    stop("Y must be a vector and match the number of rows in X")
  }
  
  # Assign names to columns of X if not already named
  if (is.null(colnames(X))) {
    colnames(X) <- paste("Var", 1:ncol(X), sep="")
  }
  
  # Convert X to a data frame
  df_X <- as.data.frame(X)
  
  # Add Y to the dataframe
  df_X$Y <- Y
  
  # Dynamically create the formula
  predictor_names <- names(df_X)[names(df_X) != "Y"]
  formula_string <- paste("Y ~", paste(predictor_names, collapse = " + "))
  
  # Fit the model using the formula
  model <- lm(formula_string, data=df_X)
  
  # Return the fitted model
  return(model)
}

# Example usage:
# Assume X is your matrix with predictors and Y is your response vector
X <- matrix(runif(100), ncol=5)  # 20 observations, 5 predictors
Y <- rnorm(20)  # 20 observations

# Fit the model
model <- fit_linear_model(X, Y)

# Print the summary of the model
summary(model)

```

```{r}
# evidence that fitting the model via the built in R function to estimate the variance results in successful calculation, even when the matrix X^T X appears to be computationally singular
set.seed(12)
X_ko <- create.fixed(regression$X, method = 'sdp')$Xk
X_temp <- cbind(regression$X, X_ko)
get_variance_parameter_estimate(regression$X, as.vector(regression$Y))
inv(t(X_temp) %*% X_temp)
```



```{r}
set.seed(12)
regression <- get_regression_model(n = 200, d = 30, a = 2, num_true_signals = 10)
result <- get_T_1(regression$X, regression$Y)
#get_T_2(regression$X, regression$Y)
```


```{r}
result
```

```{r}
diag(diag(result))
```

```{r}
solve(diag(diag(result)))
```



```{r}
is_posdef(result) # 2 * sigma - D should be positive definite, is not
```

```{r}
is_posdef(solve(diag(diag(result))))
```

```{r}
sqrtm(solve(diag(diag(result))))$B %*% sqrtm(solve(diag(diag(result))))$B
```


```{r}
sqrtm(solve(diag(diag(result))))$Binv
```

```{r}
get_variance_parameter_estimate(cbind(regression$X, create.fixed(regression$X, method = 'sdp')$Xk), regression$Y)
```

```{r}
create.solve_equi(t(regression$X) %*% regression$X)
```


```{r}
create_equicorrelated_D(regression$X)
```



